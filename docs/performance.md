# Performance

## Operation costs

| Operation | Cost | Measured | Notes |
|---|---|---|---|
| **Property get** | 1 virtual call + `memcpy` | ~8 ns | Via `Property<T>` wrapper; queries `IPropertyInternal`, then `IAny::get_data` |
| **Property set** | 1 virtual call + `memcpy` | ~9 ns | Reverse path through `IAny::set_data`; fires `on_changed` if value differs |
| **Direct state read** | Pointer dereference | ~1 ns | `IPropertyState::get_property_state<T>()` returns `T::State*`; read fields directly |
| **Direct state write** | Pointer dereference | <1 ns | Write fields via state pointer; no virtual dispatch |
| **Function invoke** | 1 indirect call | ~9 ns | `target_fn_(target_context_, args)` — context/function-pointer pair, no virtual dispatch |
| **Typed-arg trampoline** | Arg extraction + indirect call | ~34 ns | `FnBind` reads each arg via `IAny::get_data()`, then calls the virtual `fn_Name(...)` |
| **Raw function invoke** | 1 indirect call | ~11 ns | `FnRawBind` passes `FnArgs` through unchanged — no extraction overhead |
| **Event dispatch (immediate)** | Loop over handlers | ~13 ns | Iterates immediate handlers in-place; no allocations |
| **Event dispatch (deferred)** | Clone + queue | ~205 ns | Clones args once into `shared_ptr`, queues `DeferredTask`; mutex lock on insertion |
| **interface_cast** | Linear scan | ~5 ns | Walks the interface pack + parent chains; typically 2-4 interfaces, fully inlinable |
| **Metadata lookup (cold)** | Linear scan + alloc | ~845 ns | First `get_property()` call; allocates `PropertyImpl` and caches result |
| **Metadata lookup (cached)** | Cache-first scan | ~84 ns | Subsequent call; scans cached instances first, no allocation |
| **Object creation** | 2 heap allocations | ~160 ns | Factory lookup (`O(log N)`), then allocate object + `MetadataContainer` |

*Measured on AMD Ryzen 7 5800X (3.8 GHz), MSVC 19.29, Release build. Run `build/bin/Release/benchmark.exe` to reproduce.*

### Property get/set

`Property<T>::get_value()` queries `IPropertyInternal` on the property, gets the backing `IAny`, and calls `get_data(&value, sizeof(T), typeUid)` which copies data to a stack-local variable. `set_value()` follows the reverse path and fires the `on_changed` event if the value changed.

The backing `IAny` is typically an `AnyRef<T>` — a non-owning pointer into the object's inline `State` struct. For trivially-copyable types, `AnyRef<T>::set_value()` uses `memcmp` + `memcpy`. For non-trivial types, it uses direct assignment.

### Direct state access

Bypasses the property system entirely. `IPropertyState::get_property_state<T>()` returns a pointer to the interface's `State` struct stored inline in the object. Reading and writing fields is a plain pointer dereference with zero abstraction overhead.

For trivially-copyable state structs, the entire state can be snapshotted or restored with `memcpy`.

### Function invoke

`FunctionImpl` stores a `target_fn_` / `target_context_` pair. Invocation is a single indirect call: `target_fn_(target_context_, args)`. For `STRATA_INTERFACE` functions, the context is a pointer to the owning object and `target_fn_` is a static trampoline generated by `FnBind` or `FnRawBind`.

- **Zero-arg / typed-arg (`FN`)**: The `FnBind` trampoline extracts typed values from `FnArgs` via `IAny::get_data()` (one per argument), then calls the virtual `fn_Name(...)`.
- **Raw (`FN_RAW`)**: The `FnRawBind` trampoline passes `FnArgs` through unchanged — no extraction overhead.
- **Explicit callback**: `set_invoke_callback()` stores a `CallbackFn*` with a static trampoline that does one `reinterpret_cast` + call.

### Event dispatch

Handlers are stored in a single `std::vector` partitioned by invoke type: `[0, deferred_begin_)` for immediate, `[deferred_begin_, size())` for deferred.

- **Immediate handlers**: Invoked in a simple loop. No allocations.
- **Deferred handlers**: Args are cloned once into a `shared_ptr` (shared across all deferred handlers for that invocation), then queued as `DeferredTask` entries. Queue insertion takes a mutex lock. `instance().update()` swaps the queue under the lock and executes outside it — no nested locking.
- **No handlers**: The handlers vector is empty — zero heap allocation.
- **add_handler()**: Linear dedup scan before insertion, `O(H)` where H is handler count.

### interface_cast

`InterfaceDispatch::get_interface(uid)` walks the compile-time interface pack. For each interface, it compares the UID, then walks the parent interface chain (`ParentInterface` typedef) until reaching `IInterface`. Returns the first match or `nullptr`.

Complexity is `O(N + P)` where N is the number of interfaces in the pack (typically 2-4) and P is the maximum inheritance depth (typically 1-2). The template recursion is fully inlined by the compiler.

### Metadata lookup

`MetadataContainer::find_or_create(name, kind)` checks the `instances_` cache first — a linear scan of `O(M)` already-created members comparing by name and kind. On a cache hit this is the only work done, avoiding the full `members_` scan. On a cache miss, it scans the static `members_` array to find the member, allocates a new `PropertyImpl` or `FunctionImpl`, wires up the virtual dispatch trampoline, and caches the result.

Subsequent accesses for the same member skip creation and only pay the cache lookup cost. Since applications typically access a subset of declared members, the cache-first scan is shorter than the full members array. Static metadata arrays (`MemberDesc`, `InterfaceInfo`) are `constexpr` — shared across all instances at zero per-object cost.

### Object creation

1. **Factory lookup**: `O(log N)` binary search on sorted registered types vector
2. **Allocate object**: One `new FinalClass` wrapped in `shared_ptr` with ref-counting deleter
3. **Wire self-pointer**: Stores `weak_ptr` to the `shared_ptr` (for `shared_from_object()`)
4. **Allocate MetadataContainer**: One `new MetadataContainer(members, owner)` — stores a pointer to the static metadata array and the owning object
5. **State initialization**: `State` structs are default-constructed inline (part of the object allocation, not separate)

No member instances (`PropertyImpl`, `FunctionImpl`) are created until first access.

## Memory layout

An `ext::Object<T, Interfaces...>` instance carries minimal per-object data. The metadata container is heap-allocated once per object and lazily creates member instances on first access.

### ext::ObjectCore

Interface infrastructure, reference counting and `ISharedFromObject` semantics. The size depends on how many interfaces the object implements, since multiple inheritance adds a vtable pointer per interface (MSVC x64).

| Layer | Member | Size (x64) |
|---|---|---|
| ext::InterfaceDispatch | vptr per interface | grows with N |
| ext::RefCountedDispatch | refCount (`atomic<int32_t>`) | 4 |
| ext::RefCountedDispatch | flags (`int32_t`) | 4 |
| ext::ObjectCore | `self_` (`weak_ptr`) | 16 |

Measured sizes (MSVC x64):

| Configuration | Interfaces | Size |
|---|---|---|
| `ext::ObjectCore<X>` (minimal) | 1 (ISharedFromObject) | **40 bytes** |
| `ext::ObjectCore<X, IMetadataContainer, IMyWidget, ISerializable>` | 4 | **112 bytes** |

### MetadataContainer

Storage for per-object metadata.

| Member | Size |
|---|---|
| vptr | 8 |
| `members_` (`array_view`) | 16 |
| `owner_` (pointer to owning object) | 8 |
| `instances_` (vector, initially empty) | 24 |
| `dynamic_` (`unique_ptr`, initially null) | 8 |
| **Total (baseline)** | **64 bytes** |

Each accessed member adds a **24-byte** entry to the `instances_` vector:
* an 8-byte metadata index (`size_t`) plus
* a 16-byte `shared_ptr<IInterface>`.

Members are created lazily, i.e. only when first accessed via `get_property()`, `get_event()`, or `get_function()`.

Static metadata arrays (`MemberDesc`, `InterfaceInfo`) are `constexpr` data shared across all instances at zero per-object cost.

### ext::Object

Full object with ext::ObjectCore features, runtime metadata, and per-interface property state storage.

| Layer | Member | Size (x64) |
|---|---|---|
| ext::ObjectCore | [ext::ObjectCore](#extobjectcore) | varies by interface count |
| ext::Object | `meta_` (`unique_ptr<IMetadata>`) | 8 |
| ext::Object | `states_` (tuple of interface `State` structs) | varies by interfaces |
| MetadataContainer | [MetadataContainer](#metadatacontainer), heap-allocated | 64 |

The `states_` tuple contains one `State` struct per interface that declares properties via `STRATA_INTERFACE`. Each `State` struct holds one field per `PROP` member, initialized with its declared default value. Properties backed by state storage use `ext::AnyRef<T>` to read/write directly into these fields.

### Example: MyWidget with 6 members

MyWidget implements IMyWidget (2 PROP + 1 EVT + 1 FN) and ISerializable (1 PROP + 1 FN). `ext::Object` adds IMetadataContainer, totaling 4 interfaces in the dispatch pack (ISharedFromObject subsumes IObject, IMetadataContainer subsumes IMetadata and IPropertyState).

| Component | Size (x64) |
|---|---|
| ext::ObjectCore (4 interfaces) | 112 |
| `meta_` (`unique_ptr<IMetadata>`) | 8 |
| `states_` (`IMyWidget::State` (8) + `ISerializable::State` (32)) | 40 |
| **sizeof(MyWidget)** | **160 bytes** |

MetadataContainer (64 bytes) is heap-allocated separately. Member instances are created lazily as accessed.

| Scenario | MyWidget | MetadataContainer | Cached members | Total |
|---|---|---|---|---|
| No members accessed | 160 | 64 | 0 | **224 bytes** |
| 3 members accessed | 160 | 64 | 3 × 24 = 72 | **296 bytes** |
| All 6 members accessed | 160 | 64 | 6 × 24 = 144 | **368 bytes** |

### Base types

#### Any

`ext::AnyBase` types inherit `ext::RefCountedDispatch<IAny>` directly
* `IAny` inherits `IObject` (for factory compatibility) but skips `ISharedFromObject` and the `self_` weak pointer.
* The single inheritance chain (`IInterface` → `IObject` → `IAny`) means only one vptr, saving 24 bytes total vs. `ext::ObjectCore`.

| Layer | Member | Size (x64) |
|---|---|---|
| ext::InterfaceDispatch | vptr | 8 |
| ext::RefCountedDispatch | refCount (`atomic<int32_t>`) | 4 |
| ext::RefCountedDispatch | flags (`int32_t`) | 4 |
| **ext::AnyBase total** | | **16 bytes** |

`ext::AnyValue<T>` adds the stored value on top of the `ext::AnyBase` base. Measured sizes (MSVC x64):

| Type | Size |
|---|---|
| `ext::AnyValue<float>` | 32 bytes |

An example of a custom any with external data storage `MyDataAny` can be found from the demo application.

| Type | Size |
|---|---|
| `MyDataAny` (with `IExternalAny`) | 48 bytes |

#### Function

`ClassId::Function` and `ClassId::Event` are implemented by the same class.

`ClassId::Function` implements `IFunctionInternal` and `IEvent` (which inherits `IFunction`).
* The primary invoke target uses a unified context/function-pointer pair.
* Plain callbacks go through a static trampoline.
* Event handlers are stored in a single partitioned vector.

| Layer | Member | Size (x64) |
|---|---|---|
| ext::InterfaceDispatch | vptr | 8 |
| ext::RefCountedDispatch | refCount (`atomic<int32_t>`) | 4 |
| ext::RefCountedDispatch | flags (`int32_t`) | 4 |
| ext::ObjectCore | `self_` (`weak_ptr`) | 16 |
| FunctionImpl | `target_context_` (`void*`) | 8 |
| FunctionImpl | `target_fn_` (`BoundFn*`) | 8 |
| FunctionImpl | `handlers_` (`vector<ConstPtr>`) | 24 |
| FunctionImpl | `deferred_begin_` (`uint32_t`) + padding | 8 |
| **Total** | | **80 bytes** |

The `handlers_` vector is partitioned:
* `[0, deferred_begin_)` holds immediate handlers
* `[deferred_begin_, size())` holds deferred handlers.
* When no handlers are registered the vector is empty (zero heap allocation).

#### Property

`ClassId::Property` implements `IProperty` and `IPropertyInternal`. It holds a shared pointer to its backing `IAny` storage and a `LazyEvent` for change notifications.

| Layer | Member | Size (x64) |
|---|---|---|
| ext::InterfaceDispatch | vptr | 8 |
| ext::RefCountedDispatch | refCount (`atomic<int32_t>`) | 4 |
| ext::RefCountedDispatch | flags (`int32_t`) | 4 |
| ext::ObjectCore | `self_` (`weak_ptr`) | 16 |
| PropertyImpl | `data_` (`shared_ptr<IAny>`) | 16 |
| PropertyImpl | `onChanged_` (`ext::LazyEvent`) | 16 |
| PropertyImpl | `external_` (`bool`) + padding | 8 |
| **Total** | | **72 bytes** |

`ext::LazyEvent` contains a single `shared_ptr<IEvent>` (16 bytes) that is null until first access, deferring the cost of creating the underlying `FunctionImpl` until a handler is actually registered or the event is invoked.
