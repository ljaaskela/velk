# Performance

## Operation costs

| Operation | Cost | Measured | Notes |
|---|---|---|---|
| **Property get** | 1 virtual call + `memcpy` | ~8 ns | Via `Property<T>` wrapper; queries `IPropertyInternal`, then `IAny::get_data` |
| **Property set** | 1 virtual call + `memcpy` | ~9 ns | Reverse path through `IAny::set_data`; fires `on_changed` if value differs |
| **Direct state read** | Pointer dereference | ~1 ns | `IPropertyState::get_property_state<T>()` returns `T::State*`; read fields directly |
| **Direct state write** | Pointer dereference | <1 ns | Write fields via state pointer; no virtual dispatch |
| **Function invoke** | 1 indirect call | ~9 ns | `target_fn_(target_context_, args)` — context/function-pointer pair, no virtual dispatch |
| **Typed-arg trampoline** | Arg extraction + indirect call | ~34 ns | `FnBind` reads each arg via `IAny::get_data()`, then calls the virtual `fn_Name(...)` |
| **Raw function invoke** | 1 indirect call | ~11 ns | `FnRawBind` passes `FnArgs` through unchanged — no extraction overhead |
| **Event dispatch (immediate)** | Loop over handlers | ~13 ns | Iterates immediate handlers in-place; no allocations |
| **Event dispatch (deferred)** | Clone + queue | ~205 ns | Clones args once into `shared_ptr`, queues `DeferredTask`; mutex lock on insertion |
| **interface_cast** | Linear scan | ~5 ns | Walks the interface pack + parent chains; typically 2-4 interfaces, fully inlinable |
| **Metadata lookup (cold)** | Linear scan + alloc | ~845 ns | First `get_property()` call; allocates `PropertyImpl` and caches result |
| **Metadata lookup (cached)** | Cache-first scan | ~84 ns | Subsequent call; scans cached instances first, no allocation |
| **Object creation** | 2 heap allocations | ~160 ns | Factory lookup (`O(log N)`), then allocate object + `MetadataContainer` |

*Measured on AMD Ryzen 7 5800X (3.8 GHz), MSVC 19.29, Release build. Run `build/bin/Release/benchmark.exe` to reproduce.*

### Property get/set

`Property<T>::get_value()` queries `IPropertyInternal` on the property, gets the backing `IAny`, and calls `get_data(&value, sizeof(T), typeUid)` which copies data to a stack-local variable. `set_value()` follows the reverse path and fires the `on_changed` event if the value changed.

The backing `IAny` is typically an `AnyRef<T>` — a non-owning pointer into the object's inline `State` struct. For trivially-copyable types, `AnyRef<T>::set_value()` uses `memcmp` + `memcpy`. For non-trivial types, it uses direct assignment.

### Direct state access

Bypasses the property system entirely. `IPropertyState::get_property_state<T>()` returns a pointer to the interface's `State` struct stored inline in the object. Reading and writing fields is a plain pointer dereference with zero abstraction overhead.

For trivially-copyable state structs, the entire state can be snapshotted or restored with `memcpy`.

### Function invoke

`FunctionImpl` stores a `target_fn_` / `target_context_` pair. Invocation is a single indirect call: `target_fn_(target_context_, args)`. For `STRATA_INTERFACE` functions, the context is a pointer to the owning object and `target_fn_` is a static trampoline generated by `FnBind` or `FnRawBind`.

- **Zero-arg / typed-arg (`FN`)**: The `FnBind` trampoline extracts typed values from `FnArgs` via `IAny::get_data()` (one per argument), then calls the virtual `fn_Name(...)`.
- **Raw (`FN_RAW`)**: The `FnRawBind` trampoline passes `FnArgs` through unchanged — no extraction overhead.
- **Explicit callback**: `set_invoke_callback()` stores a `CallbackFn*` with a static trampoline that does one `reinterpret_cast` + call.

### Event dispatch

Handlers are stored in a single `std::vector` partitioned by invoke type: `[0, deferred_begin_)` for immediate, `[deferred_begin_, size())` for deferred.

- **Immediate handlers**: Invoked in a simple loop. No allocations.
- **Deferred handlers**: Args are cloned once into a `shared_ptr` (shared across all deferred handlers for that invocation), then queued as `DeferredTask` entries. Queue insertion takes a mutex lock. `instance().update()` swaps the queue under the lock and executes outside it — no nested locking.
- **No handlers**: The handlers vector is empty — zero heap allocation.
- **add_handler()**: Linear dedup scan before insertion, `O(H)` where H is handler count.

### interface_cast

`InterfaceDispatch::get_interface(uid)` walks the compile-time interface pack. For each interface, it compares the UID, then walks the parent interface chain (`ParentInterface` typedef) until reaching `IInterface`. Returns the first match or `nullptr`.

Complexity is `O(N + P)` where N is the number of interfaces in the pack (typically 2-4) and P is the maximum inheritance depth (typically 1-2). The template recursion is fully inlined by the compiler.

### Metadata lookup

`MetadataContainer::find_or_create(name, kind)` checks the `instances_` cache first — a linear scan of `O(M)` already-created members comparing by name and kind. On a cache hit this is the only work done, avoiding the full `members_` scan. On a cache miss, it scans the static `members_` array to find the member, allocates a new `PropertyImpl` or `FunctionImpl`, wires up the virtual dispatch trampoline, and caches the result.

Subsequent accesses for the same member skip creation and only pay the cache lookup cost. Since applications typically access a subset of declared members, the cache-first scan is shorter than the full members array. Static metadata arrays (`MemberDesc`, `InterfaceInfo`) are `constexpr` — shared across all instances at zero per-object cost.

### Object creation

1. **Factory lookup**: `O(log N)` binary search on sorted registered types vector
2. **Allocate object**: One `new FinalClass` wrapped in `shared_ptr` with ref-counting deleter
3. **Wire self-pointer**: Stores `weak_ptr` to the `shared_ptr` (for `shared_from_object()`)
4. **Allocate MetadataContainer**: One `new MetadataContainer(members, owner)` — stores a pointer to the static metadata array and the owning object
5. **State initialization**: `State` structs are default-constructed inline (part of the object allocation, not separate)

No member instances (`PropertyImpl`, `FunctionImpl`) are created until first access.

## Memory layout

An `ext::Object<T, Interfaces...>` instance carries minimal per-object data. The metadata container is heap-allocated once per object and lazily creates member instances on first access.

### Example: MyWidget with 6 members

MyWidget implements IMyWidget (2 PROP + 1 EVT + 1 FN) and ISerializable (1 PROP + 1 FN). `ext::Object` adds IMetadataContainer, totaling 4 interfaces in the dispatch pack (ISharedFromObject subsumes IObject, IMetadataContainer subsumes IMetadata and IPropertyState).

```
MyWidget (160 bytes)                        MetadataContainer (64 bytes, heap)
┌────────────────────────────────────┐      ┌────────────────────────────────┐
│ 4× vptr                        64  │      │ vptr                        8  │
│ refCount + flags                8  │      │ members_ (array_view)      16  │
│ self_ (weak_ptr)               16  │      │ owner_ (pointer)            8  │
│ meta_ (unique_ptr)              8  │      │ instances_ (vector)        24  │
│ IMyWidget::State (width,height) 8  │      │ dynamic_ (unique_ptr)       8  │
│ ISerializable::State (name)    32  │      └────────────────────────────────┘
│ (padding)                      24  │
└────────────────────────────────────┘
```

Member instances are created lazily — only when first accessed via `get_property()`, `get_event()`, or `get_function()`. Each accessed member adds a **24-byte** entry to the `instances_` vector: an 8-byte metadata index (`size_t`) plus a 16-byte `shared_ptr<IInterface>`.

| Scenario | MyWidget | MetadataContainer | Cached members | Total |
|---|---|---|---|---|
| No members accessed | 160 | 64 | 0 | **224 bytes** |
| 3 members accessed | 160 | 64 | 3 × 24 = 72 | **296 bytes** |
| All 6 members accessed | 160 | 64 | 6 × 24 = 144 | **368 bytes** |

The `states_` tuple contains one `State` struct per interface that declares properties via `STRATA_INTERFACE`. Each `State` struct holds one field per `PROP` member, initialized with its declared default value. Properties backed by state storage use `ext::AnyRef<T>` to read/write directly into these fields.

Static metadata arrays (`MemberDesc`, `InterfaceInfo`) are `constexpr` data shared across all instances at zero per-object cost.

### Common base layers

Every object starts with the same infrastructure. Multiple inheritance adds one vtable pointer per interface (MSVC x64).

- **RefCountedDispatch base** (16 bytes): vptr (8) + refCount (4) + flags (4)
- **ObjectCore** adds `self_` weak_ptr (16) = **32 bytes** base for Property, Function, and user objects
- **AnyBase** skips `self_` = **16 bytes** base for Any types (`IAny` inherits `IObject` but skips `ISharedFromObject`)

Measured ObjectCore sizes (MSVC x64):

| Configuration | Interfaces | Size |
|---|---|---|
| `ext::ObjectCore<X>` (minimal) | 1 (ISharedFromObject) | **40 bytes** |
| `ext::ObjectCore<X, IMetadataContainer, IMyWidget, ISerializable>` | 4 | **112 bytes** |

### Base types

```
AnyValue<float> (32 bytes)          MyDataAny (48 bytes)
┌────────────────────────────┐      ┌────────────────────────────┐
│ vptr                    8  │      │ 2× vptr                16  │
│ refCount + flags        8  │      │   (IAny + IExternalAny)    │
│ data_ (float) + pad    16  │      │ refCount + flags        8  │
└────────────────────────────┘      │ (MI layout padding)    24  │
                                    └────────────────────────────┘

PropertyImpl (72 bytes)             FunctionImpl (80 bytes)
┌────────────────────────────┐      ┌────────────────────────────┐
│ vptr                    8  │      │ vptr                    8  │
│ refCount + flags        8  │      │ refCount + flags        8  │
│ self_ (weak_ptr)       16  │      │ self_ (weak_ptr)       16  │
│ data_ (shared_ptr)     16  │      │ target_context_         8  │
│ onChanged_ (LazyEvent) 16  │      │ target_fn_              8  │
│ external_ + padding     8  │      │ handlers_ (vector)     24  │
└────────────────────────────┘      │ deferred_begin_ + pad   8  │
                                    └────────────────────────────┘
```

- **AnyBase** uses a single inheritance chain (`IInterface` → `IObject` → `IAny`), so only one vptr — saving 24 bytes vs. ObjectCore. `MyDataAny` is a demo application example of custom any with external data storage via `IExternalAny`; the second vptr comes from the additional interface.
- **FunctionImpl** implements both `ClassId::Function` and `ClassId::Event`. The primary invoke target uses a unified context/function-pointer pair; plain callbacks go through a static trampoline. The `handlers_` vector is partitioned: `[0, deferred_begin_)` for immediate handlers, `[deferred_begin_, size())` for deferred. When no handlers are registered the vector is empty (zero heap allocation).
- **PropertyImpl** holds a shared pointer to its backing `IAny` storage and a `LazyEvent` for change notifications. `LazyEvent` contains a single `shared_ptr<IEvent>` (16 bytes) that is null until first access, deferring the cost of creating the underlying `FunctionImpl` until a handler is actually registered or the event is invoked.
