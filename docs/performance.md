# Performance

This document covers runtime performance and memory usage related topics.

## Contents

- [Operation costs](#operation-costs)
  - [Property get/set](#property-getset)
  - [Direct state access](#direct-state-access)
  - [Function invoke](#function-invoke)
  - [Event dispatch](#event-dispatch)
  - [interface_cast](#interface_cast)
  - [Metadata lookup](#metadata-lookup)
  - [Object creation](#object-creation)
- [Memory layout](#memory-layout)
  - [Example: MyWidget with 6 members](#example-mywidget-with-6-members)
  - [Common base layers](#common-base-layers)
  - [Base types](#base-types)

## Operation costs

| Operation | Cost | Measured | Notes |
|---|---|---|---|
| **Property get** | 1 virtual call + `memcpy` | ~17 ns | Via `Property<T>` wrapper; queries `IPropertyInternal`, then `IAny::get_data` |
| **Property set** | 1 virtual call + `memcpy` | ~22 ns | Reverse path through `IAny::set_data`; fires `on_changed` if value differs |
| **Direct state read** | Pointer dereference | ~1 ns | `IPropertyState::get_property_state<T>()` returns `T::State*`; read fields directly |
| **Direct state write** | Pointer dereference | <1 ns | Write fields via state pointer; no virtual dispatch |
| **Function invoke** | 1 indirect call | ~15 ns | `target_fn_(target_context_, args)` — context/function-pointer pair, no virtual dispatch |
| **Typed-arg trampoline** | Arg extraction + indirect call | ~42 ns | `FnBind` reads each arg via `IAny::get_data()`, then calls the virtual `fn_Name(...)` |
| **Raw function invoke** | 1 indirect call | ~16 ns | `FnRawBind` passes `FnArgs` through unchanged — no extraction overhead |
| **Event dispatch (immediate)** | Loop over handlers | ~11 ns | Iterates immediate handlers in-place; no allocations |
| **Event dispatch (deferred)** | Clone + queue | ~126 ns | Clones args once into `shared_ptr`, queues `DeferredTask`; mutex lock on insertion |
| **interface_cast** | Linear scan | ~10 ns | Walks the interface pack + parent chains; typically 2-4 interfaces, fully inlinable |
| **Metadata lookup (cold)** | Linear scan + alloc | ~608 ns | First `get_property()` call; allocates `PropertyImpl` and caches result |
| **Metadata lookup (cached)** | Cache-first scan | ~35 ns | Subsequent call; scans cached instances first, no allocation |
| **Object creation** | 2 heap allocations | ~114 ns | Factory lookup (`O(log N)`), then allocate object + `MetadataContainer` |

*Measured on AMD Ryzen 7 5800X (3.8 GHz), MSVC 19.29, Release build. Run `build/bin/Release/benchmarks.exe` to reproduce.*

### Property get/set

`Property<T>::get_value()` queries `IPropertyInternal` on the property, gets the backing `IAny`, and calls `get_data(&value, sizeof(T), typeUid)` which copies data to a stack-local variable. `set_value()` follows the reverse path and fires the `on_changed` event if the value changed.

The backing `IAny` is typically an `AnyRef<T>` — a non-owning pointer into the object's inline `State` struct. For trivially-copyable types, `AnyRef<T>::set_value()` uses `memcmp` + `memcpy`. For non-trivial types, it uses direct assignment.

### Direct state access

Bypasses the property system entirely. `IPropertyState::get_property_state<T>()` returns a pointer to the interface's `State` struct stored inline in the object. Reading and writing fields is a plain pointer dereference with zero abstraction overhead.

For trivially-copyable state structs, the entire state can be snapshotted or restored with `memcpy`.

### Function invoke

`FunctionImpl` stores a `target_fn_` / `target_context_` pair. Invocation is a single indirect call: `target_fn_(target_context_, args)`. For `VELK_INTERFACE` functions, the context is a pointer to the owning object and `target_fn_` is a static trampoline generated by `FnBind` or `FnRawBind`.

- **Zero-arg / typed-arg (`FN`)**: The `FnBind` trampoline extracts typed values from `FnArgs` via `IAny::get_data()` (one per argument), then calls the virtual `fn_Name(...)`.
- **Raw (`FN_RAW`)**: The `FnRawBind` trampoline passes `FnArgs` through unchanged — no extraction overhead.
- **Explicit callback**: `set_invoke_callback()` stores a `CallbackFn*` with a static trampoline that does one `reinterpret_cast` + call.

### Event dispatch

Handlers are stored in a single `std::vector` partitioned by invoke type: `[0, deferred_begin_)` for immediate, `[deferred_begin_, size())` for deferred.

- **Immediate handlers**: Invoked in a simple loop. No allocations.
- **Deferred handlers**: Args are cloned once into a `shared_ptr` (shared across all deferred handlers for that invocation), then queued as `DeferredTask` entries. Queue insertion takes a mutex lock. `instance().update()` swaps the queue under the lock and executes outside it — no nested locking.
- **No handlers**: The handlers vector is empty — zero heap allocation.
- **add_handler()**: Linear dedup scan before insertion, `O(H)` where H is handler count.

### interface_cast

`InterfaceDispatch::get_interface(uid)` walks the compile-time interface pack. For each interface, it compares the UID, then walks the parent interface chain (`ParentInterface` typedef) until reaching `IInterface`. Returns the first match or `nullptr`.

Complexity is `O(N + P)` where N is the number of interfaces in the pack (typically 2-4) and P is the maximum inheritance depth (typically 1-2). The template recursion is fully inlined by the compiler.

### Metadata lookup

`MetadataContainer::find_or_create(name, kind)` checks the `instances_` cache first — a linear scan of `O(M)` already-created members comparing by name and kind. On a cache hit this is the only work done, avoiding the full `members_` scan. On a cache miss, it scans the static `members_` array to find the member, allocates a new `PropertyImpl` or `FunctionImpl`, wires up the virtual dispatch trampoline, and caches the result.

Subsequent accesses for the same member skip creation and only pay the cache lookup cost. Since applications typically access a subset of declared members, the cache-first scan is shorter than the full members array. Static metadata arrays (`MemberDesc`, `InterfaceInfo`) are `constexpr` — shared across all instances at zero per-object cost.

### Object creation

1. **Factory lookup**: `O(log N)` binary search on sorted registered types vector
2. **Allocate object**: One `new FinalClass` wrapped in `shared_ptr` with ref-counting deleter
3. **Wire self-pointer**: Stores `IObject*` in `control_block::ptr` (for `shared_from_object()`; reconstructs `shared_ptr` on demand)
4. **Allocate MetadataContainer**: One `new MetadataContainer(members, owner)` — stores a pointer to the static metadata array and the owning object
5. **State initialization**: `State` structs are default-constructed inline (part of the object allocation, not separate)

No member instances (`PropertyImpl`, `FunctionImpl`) are created until first access.

## Memory layout

An `ext::Object<T, Interfaces...>` instance carries minimal per-object data. The metadata container is heap-allocated once per object and lazily creates member instances on first access.

### Example: MyWidget with 6 members

MyWidget implements IMyWidget (2 PROP + 1 EVT + 1 FN) and ISerializable (1 PROP + 1 FN). `ext::Object` adds IMetadataContainer, totaling 4 interfaces in the dispatch pack (IObject, IMetadataContainer which subsumes IMetadata and IPropertyState, IMyWidget, ISerializable).

```
MyWidget (152 bytes)                        MetadataContainer (72 bytes, heap)
┌──────────────────────────────────┐      ┌────────────────────────────────┐
│ MI base layout               88  │      │ base (InterfaceDispatch)   16  │
│   (4 vptrs + MI padding)         │      │ members_ (array_view)      16  │
│ refCount + flags              8  │      │ owner_ (pointer)            8  │
│ block*                        8  │      │ instances_ (vector)        24  │
│ meta_ (unique_ptr)            8  │      │ dynamic_ (unique_ptr)       8  │
│ IMyWidget::State              8  │      └────────────────────────────────┘
│   (width, height: 2× float)      │
│ ISerializable::State         32  │
│   (name: std::string)            │
└──────────────────────────────────┘
```

The MI base layout (88 bytes) contains 4 vtable pointers — one per interface chain — plus MSVC multiple-inheritance adjustment padding. The exact layout is compiler-specific; the total is derived from `sizeof(ObjectCore<X, IMetadataContainer, IMyWidget, ISerializable>)` = 104 minus ObjectData (16). The self-pointer (`IObject*`) is stored in `control_block::ptr` rather than inline, so it costs no per-object space beyond the already-allocated block.

Member instances are created lazily — only when first accessed via `get_property()`, `get_event()`, or `get_function()`. Each accessed member adds a **24-byte** entry to the `instances_` vector: an 8-byte metadata index (`size_t`) plus a 16-byte `shared_ptr<IInterface>`.

| Scenario | MyWidget | MetadataContainer | Cached members | Total |
|---|---|---|---|---|
| No members accessed | 152 | 72 | 0 | **224 bytes** |
| 3 members accessed | 152 | 72 | 3 × 24 = 72 | **296 bytes** |
| All 6 members accessed | 152 | 72 | 6 × 24 = 144 | **368 bytes** |

The `states_` tuple contains one `State` struct per interface that declares properties via `VELK_INTERFACE`. Each `State` struct holds one field per `PROP` member, initialized with its declared default value. Properties backed by state storage use `ext::AnyRef<T>` to read/write directly into these fields.

Static metadata arrays (`MemberDesc`, `InterfaceInfo`) are `constexpr` data shared across all instances at zero per-object cost.

### Common base layers

Every object starts with the same infrastructure. Multiple inheritance adds one vtable pointer per interface chain (MSVC x64). Each `RefCountedDispatch` stores an `ObjectData` struct containing the intrusive reference count, object flags, and a `control_block*` for `shared_ptr`/`weak_ptr` support.

The control block comes in two variants: `control_block` (16 bytes: strong + weak + ptr) for IInterface types, and `external_control_block` (24 bytes) which adds a type-erased `destroy` function pointer for non-IInterface types managed by `shared_ptr`.

- **RefCountedDispatch base** (32 bytes): vptr (8) + MI/alignment padding (8) + refCount (4) + flags (4) + block* (8)
- **ObjectCore** adds IObject = **56 bytes** base (with 1 extra interface) for Property, Function, and user objects. `get_self()` reconstructs a `shared_ptr` from `control_block::ptr`.
- **AnyBase** skips `self_` and uses a single inheritance chain = **32 bytes** base for Any types

Measured ObjectCore sizes (MSVC x64):

| Configuration | Interfaces | Size |
|---|---|---|
| `ext::ObjectCore<X, I>` (1 extra interface) | 2 (IObject + I) | **56 bytes** |
| `ext::ObjectCore<X, IMetadataContainer, IMyWidget, ISerializable>` | 4 | **104 bytes** |

### Base types

```
AnyValue<float> (40 bytes)
┌────────────────────────────┐
│ vptr                    8  │
│ (alignment padding)     8  │
│ refCount + flags        8  │
│ block*                  8  │
│ data_ (float) + pad     8  │
└────────────────────────────┘

PropertyImpl (96 bytes)             FunctionImpl (120 bytes)
┌────────────────────────────┐      ┌────────────────────────────┐
│ MI base layout          64 │      │ MI base layout          64 │
│   (2 vptrs + MI padding)   │      │   (2 vptrs + MI padding)   │
│ refCount + flags         8 │      │ refCount + flags         8 │
│ block*                   8 │      │ block*                   8 │
│ data_ (shared_ptr)      16 │      │ target_context_          8 │
│ onChanged_ (LazyEvent)  16 │      │ target_fn_               8 │
│ external_ (bool) + pad   8 │      │ owned_context_           8 │
│ (total verified: 96)       │      │ context_deleter_         8 │
└────────────────────────────┘      │ handlers_ (vector)      24 │
                                    │ deferred_begin_ + pad    8 │
                                    │ (total verified: 120)      │
                                    └────────────────────────────┘
```

Internal interface types use inheritance to reduce MI chains: `IPropertyInternal` inherits `IProperty`, `IFunctionInternal` inherits `IEvent` (which inherits `IFunction`), and `IFutureInternal` inherits `IFuture`. This means each impl class only needs one entry in its interface pack (the Internal variant), halving the MI vptr overhead compared to listing both the public and internal interfaces separately.

- **AnyValue** uses a single inheritance chain (`IInterface` → `IObject` → `IAny`), so only one vptr. The `control_block*` in `ObjectData` supports `shared_ptr`/`weak_ptr` interop — it is always heap-allocated at construction.
- **FunctionImpl** implements both `ClassId::Function` and `ClassId::Event`. The primary invoke target uses a unified context/function-pointer pair; plain callbacks go through a static trampoline. Owned callbacks (`set_owned_callback`) store heap-allocated context with a type-erased deleter. The `handlers_` vector is partitioned: `[0, deferred_begin_)` for immediate handlers, `[deferred_begin_, size())` for deferred. When no handlers are registered the vector is empty (zero heap allocation).
- **PropertyImpl** holds a shared pointer to its backing `IAny` storage and a `LazyEvent` for change notifications. `LazyEvent` contains a single `shared_ptr<IEvent>` (16 bytes) that is null until first access, deferring the cost of creating the underlying `FunctionImpl` until a handler is actually registered or the event is invoked.
